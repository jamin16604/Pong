---

---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Javascript Pong</title>
		<style>
			* {
				margin: 0;
				padding: 0;
			}
			body {
				overflow: hidden;
			}
			canvas{
				background-color: #111;
			}
			h1{
				color: #fff;
				font-size: 4rem;	
				font-family:sans-serif;
				bottom: 100px;
				position: absolute;
			}
			#P1Score{
				left: 35%;
			}
			#P2Score{
				right: 35%;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas"></canvas>
		<h1 id="P1Score">0</h1>
		<h1 id="P2Score">0</h1>
		<script>
			const canvas = document.getElementById("canvas",) as HTMLCanvasElement;
			const ctx = canvas.getContext("2d");
			const keysPressed = [];
			const KEY_UP = "w";
			const KEY_DOWN = "s";
			window.addEventListener('keydown', function (e) {
				keysPressed[e.key] = true;
			});
			window.addEventListener('keyup', function (e) {
				keysPressed[e.key] = false;
			});

			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			function vec2(x, y) {
				return {
					x: x,
					y: y,
				};
			}
			function Ball(pos, velocity, radius) {
				this.pos = pos;
				this.velocity = velocity;
				this.radius = radius;

				this.update = function () {
					this.pos.x += this.velocity.x;
					this.pos.y += this.velocity.y;
				};

				this.draw = function () {
					ctx.fillStyle = "#44D62C";
					ctx.strokeStyle = "#44D62C";
					ctx.beginPath();
					ctx.arc(this.pos.x,this.pos.y,this.radius,0,2 * Math.PI,);
					ctx.fill();
					ctx.stroke();
				};
				
				
			}
			function Paddle(pos, velocity, width, height) {
				this.pos = pos;
				this.velocity = velocity;
				this.width = width;
				this.height = height;
				this.score = 0;

				this.update = function () {
					if(keysPressed[KEY_UP]){
						this.pos.y -= this.velocity.y;
					}
					if(keysPressed[KEY_DOWN]){
						this.pos.y += this.velocity.y;
					}
				};

				this.draw = function () {
					ctx.fillStyle = "#44D62C";
					ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
				}
				this.getHalfWidth = function(){return this.width/2;}
				this.getHalfHeight = function(){return this.height/2;}
				this.getCentre = function(){
					return vec2(this.pos.x + this.getHalfWidth(), this.pos.y + this.getHalfHeight());
				}
			}
			
			/* Ensures ball bounces off edges of canvas to prevent it moving outside visible area*/
			function ballCollisionWithEdges(ball){
				if(ball.pos.y + ball.radius >= canvas.height || ball.pos.y - ball.radius <= 0){
					ball.velocity.y *= -1;
				}
			}

			function increaseScore(ball, paddleL, paddleR){
				if(ball.pos.x <= -ball.radius){
					paddleR.score += 1;
					document.getElementById("P2Score").innerHTML = paddleR.score;
					resetBall(ball);
				}
				if(ball.pos.x >= canvas.width + ball.radius){
					ball.velocity.x *= -1;
					paddleL.score +=1;
					document.getElementById("P1Score").innerHTML = paddleL.score;
					resetBall(ball);
				}
			}

			function resetBall(ball){
				if (ball.velocity.x > 0){
					ball.pos.x = canvas.width - 150;
				}
				if(ball.velocity < 0){
					ball.pos.x = 150;
				}
				ball.pos.y = (Math.random() * (canvas.height - 200)) + 100;
				ball.velocity.x *=-1;
				ball.velocity.y *=-1;
			}

			function paddleCollisionWithEdges(paddle){
				if(paddle.pos.y + paddle.height >= canvas.height ){
					paddle.pos.y = canvas.height - paddle.height;
				}
				if(paddle.pos.y <= 0){
					paddle.pos.y = 0;
				}
			}

			function paddleBallCollision(ball, paddle){
				let dx = Math.abs(ball.pos.x - paddle.getCentre().x);
				let dy = Math.abs(ball.pos.y - paddle.getCentre().y);
				if(dx <= (ball.radius + paddle.getHalfWidth()) && dy <= (ball.radius + paddle.getHalfHeight())){
					ball.velocity.x *= -1;
				} 
			}

			function player2CPU(ball, paddle){
				if(ball.velocity <= 0){
					return;
				}
				if( ball.pos.y> paddle.pos.y){
					paddle.pos.y += paddle.velocity.y;
					if(paddle.pos.y + paddle.height >= canvas.height ){
						paddle.pos.y = canvas.height - paddle.height;
					}
				}
				if(ball.pos.y < paddle.pos.y){
					paddle.pos.y -= paddle.velocity.y;
					if(paddle.pos.y <= 0){
						paddle.pos.y = 0;
					}
				}
			}

			function gameUpdate() {
				ball.update();
				paddleLeft.update();
				ballCollisionWithEdges(ball);
				paddleCollisionWithEdges(paddleLeft);
				paddleCollisionWithEdges(paddleRight);
				paddleBallCollision(ball, paddleLeft);
				//player2CPU(ball, paddleLeft);
				player2CPU(ball, paddleRight);
				paddleBallCollision(ball, paddleRight);
				increaseScore(ball, paddleLeft, paddleRight);
			}
			function gameDraw() {
				ball.draw();
				paddleLeft.draw();
				paddleRight.draw();
			}
			function gameLoop() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				window.requestAnimationFrame(gameLoop);

				gameUpdate();
				gameDraw();
			}
			const ball = new Ball(vec2(200, 200), vec2(10, 10), 20);
			const paddleLeft = new Paddle(vec2(0, 50), vec2(10,10), 20, 160);
			const paddleRight = new Paddle(vec2(canvas.width - 20, 30), vec2(10,10), 20, 160);
			gameLoop();
		</script>
	</body>
</html>
